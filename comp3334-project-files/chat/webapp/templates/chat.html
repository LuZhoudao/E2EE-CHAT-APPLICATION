<!DOCTYPE html>
<html lang="en">
<!-- 
This software is provided under the BSD License. Copyright (c) 2024 Xavier de CarnÃ© de Carnavalet.
Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the original author is acknowledged. See JavaScript source for full license text.
-->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat Application</title>
    <!-- Bootstrap CSS for styling -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <!-- Custom CSS -->
    <link href="{{ url_for('static', filename='styles.css') }}" rel="stylesheet">
</head>
<body>
<div class="container mt-4">
    <h2>Chat Application <small> - (<a href="/logout">Logout</a>)</small></h2>
    <div class="chat-box">
        <!-- Chat messages container -->
        <div id="messages" style="border:1px solid #ccc; height:300px; margin-bottom:20px; overflow-y:scroll; padding:10px;"></div>
        <!-- User selection dropdown -->
        <select id="userList" class="form-control mb-2">
            <option value="-1" disabled selected><i>Choose a contact</i></option>
            <!-- User options populated here -->
        </select>
        <!-- Message input -->
        <textarea id="messageInput" class="form-control mb-2" placeholder="Type a message..."></textarea>
        <div class="d-flex justify-content-between">
            <button onclick="sendMessage()" class="btn btn-primary">Send</button>
            <div>
                <button onclick="refreshKeys()" class="btn btn-secondary btn-sm">Refresh Keys</button>
                <button onclick="eraseChat()" class="btn btn-danger btn-sm">Erase Chat</button>
            </div>
        </div>
    </div>
</div>

<!-- jQuery for simplified JavaScript -->
<script src="https://code.jquery.com/jquery-3.7.1.min.js" integrity="sha384-1H217gwSVyLSIfaLxHbE7dRb3v4mYCKbpQvzx0cegeju1MVsGrX5xXxAvs/HgeFs" crossorigin="anonymous"></script>
<script type="text/javascript">
// Global variables
let lastMessageId = 0;
let peer_id = -1;
const myID = {{ sender_id }};
let userInfo = {};
let userPrivateKey;
let sharedSecrets = {}; // Object to store shared secrets with each peer
let ivCounters = {};

async function fetchAndSetupEncryptionWithPeer(peerId) {
    const peerPublicKey = await fetchPeerPublicKey(peerId);
    // Convert peerPublicKey from fetched format to ArrayBuffer if necessary

    const importedPeerPublicKey = await window.crypto.subtle.importKey(
        "spki",
        peerPublicKey, // Ensure this is an ArrayBuffer
        { name: "ECDH", namedCurve: "P-384" },
        false,
        []
    );

    const sharedSecret = await window.crypto.subtle.deriveBits(
        { name: "ECDH", public: importedPeerPublicKey },
        userPrivateKey,
        384
    );

    // Convert sharedSecret into encryption keys using HKDF
    // Store in sharedSecrets object for use in encryption/decryption
}


// Placeholder function to send public key to server

async function checkAndGenerateKeys() {
    // Check if a private key already exists in localStorage
    const existingPrivateKey = localStorage.getItem('privateKey');

    if (!existingPrivateKey) {
        // No existing private key, generate a new key pair
        const keyPair = await window.crypto.subtle.generateKey(
            {
                name: "ECDH",
                namedCurve: "P-384"
            },
            true, // set to true to make the keys extractable (i.e., you can export them)
            ["deriveKey", "deriveBits"]
        );

        // Export the private key and store it in localStorage
        const exportedPrivateKey = await window.crypto.subtle.exportKey(
            "pkcs8",
            keyPair.privateKey
        );
        const privateKeyBase64 = window.btoa(String.fromCharCode(...new Uint8Array(exportedPrivateKey)));
        localStorage.setItem('privateKey', privateKeyBase64);

        // Export the public key, convert it to Base64, and prepare to send it to the server
        const exportedPublicKey = await window.crypto.subtle.exportKey(
            "spki",
            keyPair.publicKey
        );
        const publicKeyBase64 = window.btoa(String.fromCharCode(...new Uint8Array(exportedPublicKey)));

        // Send the public key to the server
        // Replace this URL with your actual endpoint that handles the public key reception
        const response = await fetch('/api/sendPublicKey', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ publicKey: publicKeyBase64 }),
        });

        if (!response.ok) {
            throw new Error('Failed to send public key to server');
        }
        console.log('Public key sent successfully');
    } else {
        console.log('Existing private key found, no need to generate a new one');
    }
}

// Call the function to check for an existing private key or generate a new one
checkAndGenerateKeys().catch(console.error);



async function deriveKeys(sharedSecretBits, salt, peer_id, direction = 'to') {
    console.log("Deriving keys!!!");

    // Import the raw shared secret bits as a CryptoKey for use with HKDF
    const sharedSecretKey = await window.crypto.subtle.importKey(
        "raw",
        sharedSecretBits,
        { name: "HKDF" },
        false,
        ["deriveKey"]
    );

    // Define HKDF parameters
    const baseInfo = `CHAT_KEY_USER${direction}${peer_id}`;
    const encryptionInfo = `${baseInfo}_ENCRYPTION`;
    const macInfo = `${baseInfo}_MAC`;

    // Derive the AES-GCM encryption key
    const aesKey = await window.crypto.subtle.deriveKey(
        {
            name: "HKDF",
            salt: salt,
            info: new TextEncoder().encode(encryptionInfo),
            hash: "SHA-256"
        },
        sharedSecretKey, // Use the imported shared secret key here
        { name: "AES-GCM", length: 256 },
        true, ["encrypt", "decrypt"]
    );

    // Derive the HMAC key
    const macKey = await window.crypto.subtle.deriveKey(
        {
            name: "HKDF",
            salt: salt,
            info: new TextEncoder().encode(macInfo),
            hash: "SHA-256"
        },
        sharedSecretKey, // And also here
        { name: "HMAC", hash: "SHA-256" },
        true, ["sign", "verify"]
    );

    console.log("Derived AES Key:", aesKey);
    console.log("Derived MAC Key:", macKey);

    return { aesKey, macKey };
}


        
        // Example usage
        async function startKeyDerivation() {
            
            const sharedSecret = await deriveSharedSecret(); 
            const salt = window.crypto.getRandomValues(new Uint8Array(16)); // Generate a unique salt
        
            const { aesKey, macKey } = await deriveKeys(sharedSecret, salt, peer_id, 'to');
            storeKeys(aesKey,macKey,peer_id);

           
        }


// Function to generate a unique IV based on a counter
function generateIVForUser(userId, direction) {
    if (!ivCounters[userId]) {
        ivCounters[userId] = { send: 0, receive: 0 };
    }
    ivCounters[userId][direction] += 1;
    const ivCounter = ivCounters[userId][direction];
    const iv = new Uint8Array(12); // 96-bit IV
    iv.set(new Uint8Array([ivCounter >> 24, ivCounter >> 16, ivCounter >> 8, ivCounter]), 8); // Example counter usage
    return iv;
}

// Assuming aesKey and macKey are already derived and available
// ivCounters should be managed globally to track IVs for each chat session

async function storeKeys(aesKey, macKey, peer_id) {
    console.log("storekeys!!!!!!");
    // Export the AES-GCM encryption key
    const aesKeyExported = await window.crypto.subtle.exportKey("jwk", aesKey);
    // Export the HMAC key
    const macKeyExported = await window.crypto.subtle.exportKey("jwk", macKey);

    // Serialize and store in Local Storage
    localStorage.setItem('aesKey', JSON.stringify(aesKeyExported));
    localStorage.setItem('macKey', JSON.stringify(macKeyExported));

    // Store peer_id
    localStorage.setItem('peer_id', peer_id);
}

document.addEventListener('DOMContentLoaded', function() {
    document.getElementById('userList').addEventListener('change', function() {
        const selectedUserId = this.value;
        localStorage.setItem('peer_id', selectedUserId);
    });

    // Other initialization code can go here
});

async function sendMessage() {
    // Retrieve peer_id and the keys from Local Storage
    const peer_id = localStorage.getItem('peer_id');
    if (!peer_id) {
        console.error("No receiver selected or peer_id missing in Local Storage.");
        return;
    }

    const aesKeyJwk = JSON.parse(localStorage.getItem('aesKey'));
    const macKeyJwk = JSON.parse(localStorage.getItem('macKey'));
    if (!aesKeyJwk || !macKeyJwk) {
        console.error("Encryption or MAC key missing in Local Storage.");
        return;
    }

    // Import the keys back into CryptoKey objects for encryption and signing
    const aesKey = await window.crypto.subtle.importKey("jwk", aesKeyJwk, { name: "AES-GCM" }, false, ["encrypt"]);
    const macKey = await window.crypto.subtle.importKey("jwk", macKeyJwk, { name: "HMAC", hash: { name: "SHA-256" } }, false, ["sign"]);

    const message = document.getElementById('messageInput').value;
    if (!message) {
        console.error("No message to send.");
        return;
    }

    // Generate a unique IV and prepare AAD
    const iv = generateIVForUser(peer_id, 'send');
    const encoder = new TextEncoder();
    const additionalData = encoder.encode(`CHAT_MSG_FROM_${myID}_TO_${peer_id}`);

    // Encrypt the message
    const encryptedData = await window.crypto.subtle.encrypt({ name: "AES-GCM", iv, additionalData }, aesKey, encoder.encode(message));

    // Sign the IV with HMAC to ensure its integrity
    const hmacSignature = await window.crypto.subtle.sign("HMAC", macKey, iv);

    // Convert encrypted data and HMAC signature to Base64 for sending
    const encryptedDataB64 = arrayBufferToBase64(encryptedData);
    const hmacSignatureB64 = arrayBufferToBase64(hmacSignature);

    // Send the encrypted message and HMAC signature to the server
    const response = await fetch('/api/send_message', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
            peer_id: peer_id,
            ciphertext: encryptedDataB64,
            iv: arrayBufferToBase64(iv),
            hmac: hmacSignatureB64,
            // Add other data here
        }),
    });

    if (!response.ok) {
        throw new Error('Failed to send encrypted message to the server');
    }

    console.log("Encrypted message and HMAC signature sent to server");
    document.getElementById('messageInput').value = ''; // Clear the input field after sending
}


// Helper functions for IV generation and Base64 conversions not shown here, ensure they are implemented


async function decryptAndVerifyMessage(senderUserId, encryptedData, aesKey, macKey) {
    const decoder = new TextDecoder();
    const { ciphertext, iv, hmac, additionalData } = encryptedData; // Assuming these are provided in Base64 format

    // Convert from Base64 to ArrayBuffer
    const ciphertextArrayBuffer = base64ToArrayBuffer(ciphertext);
    const ivArrayBuffer = base64ToArrayBuffer(iv);
    const hmacArrayBuffer = base64ToArrayBuffer(hmac);

    // First, verify the HMAC to ensure the IV has not been tampered with
    const isValidHmac = await window.crypto.subtle.verify(
        {
            name: "HMAC",
        },
        macKey,
        hmacArrayBuffer, // The received HMAC
        ivArrayBuffer // The received IV
    );

    if (!isValidHmac) {
        throw new Error("HMAC verification failed: IV has been tampered with or message integrity compromised.");
    }

    // Check IV for replay attacks by ensuring it's greater than the last known IV for this sender
    const lastKnownIvCounter = ivCounters[senderUserId]?.receive || 0;
    const receivedIvCounter = new DataView(ivArrayBuffer.slice(8)).getUint32(0, false); // Assuming counter is stored in the last 4 bytes

    if (receivedIvCounter <= lastKnownIvCounter) {
        throw new Error("Replay attack detected: received IV is not greater than the last known IV.");
    }
    // Update the last known IV counter for this sender
    if (!ivCounters[senderUserId]) ivCounters[senderUserId] = {};
    ivCounters[senderUserId].receive = receivedIvCounter;

    // Decrypt the message
    const decrypted = await window.crypto.subtle.decrypt(
        {
            name: "AES-GCM",
            iv: ivArrayBuffer,
            additionalData: additionalData ? base64ToArrayBuffer(additionalData) : undefined,
        },
        aesKey,
        ciphertextArrayBuffer
    );

    // Convert decrypted message back to a string
    const decryptedMessage = decoder.decode(decrypted);

    return {
        message: decryptedMessage,
        senderUserId
    };
}

// Helper function to convert Base64 to ArrayBuffer
function base64ToArrayBuffer(base64) {
    const binaryString = window.atob(base64);
    const len = binaryString.length;
    const bytes = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
        bytes[i] = binaryString.charCodeAt(i);
    }
    return bytes.buffer;
}

// Helper function to convert ArrayBuffer to Base64
function arrayBufferToBase64(buffer) {
    let binary = '';
    const bytes = new Uint8Array(buffer);
    const len = bytes.byteLength;
    for (let i = 0; i < len; i++) {
        binary += String.fromCharCode(bytes[i]);
    }
    return window.btoa(binary);
}


// Refresh Keys function placeholder
function refreshKeys() {
    console.log('Refresh keys functionality will be implemented here.');

    // Placeholder for refresh functionality
}

// Populate users function
function populateUsers(users) {
    const userListDropdown = document.getElementById("userList");
    users.forEach(user => {
        const option = new Option(user[1], user[0]); // username as text, user_id as value
        userListDropdown.add(option);
    });
}

// Fetch users from server
$(document).ready(function() {
    fetch('/users')
        .then(response => response.json())
        .then(data => {
            data.users.forEach(user => {
                userInfo[user[0]] = user[1]; // Map user_id to username
            });
            console.log(userInfo);
            populateUsers(data.users);
        })
        .catch(error => console.error('Error fetching user info:', error));
});

// Handle user selection change
document.getElementById('userList').addEventListener('change', async(event) => {
    peer_id = parseInt(event.target.value, 10); // Convert selected peer_id to integer
    console.log("peer changed:", peer_id);
    try {
        const response = await fetch(`/get_public_key/${peer_id}`);
        if (!response.ok) {
            throw new Error('Failed to fetch public key');
        }
        const data = await response.json();
        console.log('Public Key:', data.public_key);

        // Store the fetched public key in localStorage
        localStorage.setItem(`publicKey_${peer_id}`, data.public_key);
        
        startKeyDerivation();

        // Proceed to setup encryption or any other necessary steps
    } catch (error) {
        console.error('Error fetching public key:', error);
    }
    
    clearChatBox();
    lastMessageId = 0;
    fetchMessages(); // Fetch messages for the new selection
});

async function deriveSharedSecret() {
    // Retrieve the Base64-encoded keys from localStorage
    const privateKeyBase64 = localStorage.getItem('privateKey');
    const peerPublicKeyBase64 = localStorage.getItem(`publicKey_${peer_id}`);

    // Decode the Base64 strings to ArrayBuffers
    const privateKeyArrayBuffer = base64ToArrayBuffer(privateKeyBase64);
    const peerPublicKeyArrayBuffer = base64ToArrayBuffer(peerPublicKeyBase64);

    // Import the private key
    const privateKey = await window.crypto.subtle.importKey(
        "pkcs8",
        privateKeyArrayBuffer,
        {
            name: "ECDH",
            namedCurve: "P-384"
        },
        false, 
        ["deriveKey", "deriveBits"] 
    );

    // Import the peer's public key
    const peerPublicKey = await window.crypto.subtle.importKey(
        "spki",
        peerPublicKeyArrayBuffer,
        {
            name: "ECDH",
            namedCurve: "P-384" 
        },
        false, 
        [] 
    );

    // Derive the shared secret
    const sharedSecret = await window.crypto.subtle.deriveKey(
        {
            name: "ECDH",
            public: peerPublicKey 
        },
        privateKey, 
        {
            name: "AES-GCM",
            length: 256, 
        },
        false, 
        ["encrypt", "decrypt"] 
    );
        //derive it as raw 
    const bits = await window.crypto.subtle.deriveBits(
        {
            name: "ECDH",
            public: peerPublicKey 
        },
        privateKey, 
        256
    );

    //console.log("Derived shared secret:", sharedSecret);
    //console.log("Derived bits: ", bits);
    return bits;
    //return sharedSecret;
}



// Clear chat box
function clearChatBox() {
    document.getElementById('messages').innerHTML = '';
}

// Fetch messages from server
function fetchMessages() {
    if (peer_id === -1) return; // Exit if no peer selected
    fetch(`/fetch_messages?last_message_id=${lastMessageId}&peer_id=${peer_id}`)
        .then(response => response.json())
        .then(data => {
            data.messages.forEach(message => {
                displayMessage(message);
                lastMessageId = message.message_id;
            });
        })
        .catch(error => console.error('Error fetching messages:', error));
}

// Display a single message
function displayMessage(message) {
    const messagesContainer = document.getElementById('messages');
    const messageElement = document.createElement('div');

    // Determine sender and receiver strings
    const sender = message.sender_id == myID ? "me" : (userInfo[message.sender_id] || `User ${message.sender_id}`);
    const receiver = message.receiver_id == myID ? "me" : (userInfo[message.receiver_id] || `User ${message.receiver_id}`);

    messageElement.textContent = `From ${sender} to ${receiver}: ${message.message_text}`;
    messagesContainer.appendChild(messageElement);
}

// Periodically fetch new messages every second
setInterval(fetchMessages, 1000);

// Erase Chat function using fetch API
function eraseChat() {
    if (peer_id === -1) return; // Exit if no peer selected
    if (!confirm('Are you sure you want to erase the chat with '+userInfo[peer_id]+'?')) return; // Confirmation before erasing

    fetch(`/erase_chat`, {
        method: 'POST',  // A REST API should use POST if it leads to modifications
        headers: {
            'Content-Type': 'application/json', 
        },
        body: JSON.stringify({ peer_id: peer_id })
    })
    .then(response => {
        if (!response.ok) {
            throw new Error('Network response was not ok');
        }
        return response.json(); // Assuming the server responds with JSON
    })
    .then(data => {
        console.log('Chat erased:', data);
        clearChatBox(); // Clear the chat display
    })
    .catch(error => {
        console.error('Error erasing chat:', error);
    });
}

</script>
</body>
</html>
